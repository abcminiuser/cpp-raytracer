#include "SceneLoader.hpp"

#include "Engine/Color.hpp"
#include "Engine/Material.hpp"
#include "Engine/Material/DebugMaterial.hpp"
#include "Engine/Material/DielectricMaterial.hpp"
#include "Engine/Material/DiffuseMaterial.hpp"
#include "Engine/Material/LightMaterial.hpp"
#include "Engine/Material/ReflectiveMaterial.hpp"
#include "Engine/Mesh.hpp"
#include "Engine/Object.hpp"
#include "Engine/Object/BoxObject.hpp"
#include "Engine/Object/MeshObject.hpp"
#include "Engine/Object/PlaneObject.hpp"
#include "Engine/Object/SphereObject.hpp"
#include "Engine/Scene.hpp"
#include "Engine/Texture.hpp"
#include "Engine/Texture/CheckerboardTexture.hpp"
#include "Engine/Texture/ImageTexture.hpp"
#include "Engine/Texture/SolidTexture.hpp"
#include "Engine/Transform.hpp"
#include "Engine/Vector.hpp"

#include <SFML/Graphics.hpp>

#include <OBJ_Loader.h>

#include <fkYAML/node.hpp>

#include <fstream>
#include <map>
#include <numbers>
#include <regex>
#include <stdexcept>
#include <stdint.h>
#include <vector>

namespace
{
	std::string TrimWhitespace(std::string value)
	{
		if (auto pos = value.find_first_not_of(" \t"); pos != std::string::npos)
			value = value.substr(pos);

		if (auto pos = value.find_last_not_of(" \t"); pos != std::string::npos)
			value = value.substr(0, pos + 1);

		return value;
	}

	constexpr double DegreesToRadians(double degrees)
	{
		return degrees * (std::numbers::pi / 180);
	}

	double DoubleFromString(std::string str)
	{
		str = TrimWhitespace(str);

		char* parsedEnd;
		double value = std::strtod(str.data(), &parsedEnd);

		if (parsedEnd != (str.data() + str.size()))
			throw std::runtime_error("Failed to parse double '" + str + "' in scene YAML file");

		return value;
	}

	std::shared_ptr<ImageTexture> MakeImageTexture(const std::string& path, const Color& multiplier, Texture::Interpolation interpolation)
	{
		sf::Image imageTexture;
		if (! imageTexture.loadFromFile(path))
			throw std::runtime_error("Failed to load image: " + path);

		const auto	dimensions	= imageTexture.getSize();
		const auto* pixels		= imageTexture.getPixelsPtr();

		return std::make_shared<ImageTexture>(dimensions.x, dimensions.y, multiplier, interpolation, reinterpret_cast<const uint32_t*>(pixels));
	}

	std::shared_ptr<Mesh> MakeObjectMesh(const std::string& path)
	{
		objl::Loader objLoader;
		if (! objLoader.LoadFile(path))
			throw std::runtime_error("Failed to load object file: " + path);

		std::vector<Vertex>		vertices;
		std::vector<Triangle>	triangles;

		for (const auto& mesh : objLoader.LoadedMeshes)
		{
			printf("Adding sub-mesh '%s'\n", mesh.MeshName.empty() ? "(Unnamed)" : mesh.MeshName.c_str());

			const uint32_t meshStartPos = static_cast<uint32_t>(vertices.size());

			vertices.reserve(vertices.size() + mesh.Vertices.size());
			triangles.reserve(triangles.size() + (mesh.Indices.size() / 3));

			for (const auto& v : mesh.Vertices)
			{
				vertices.emplace_back(
					Vertex
					{
						.position	= Vector(static_cast<double>(v.Position.X), static_cast<double>(v.Position.Y), static_cast<double>(v.Position.Z)),
						.normal		= Vector(static_cast<double>(v.Normal.X), static_cast<double>(v.Normal.Y), static_cast<double>(v.Normal.Z)),
						.texture	= Vector(static_cast<double>(v.TextureCoordinate.X), static_cast<double>(v.TextureCoordinate.Y), 0.0)
					}
				);
			}

			for (size_t i = 0; i < mesh.Indices.size(); i += 3)
				triangles.emplace_back(Triangle{ meshStartPos + mesh.Indices[i + 0], meshStartPos + mesh.Indices[i + 1], meshStartPos + mesh.Indices[i + 2] });
		}

		return std::make_shared<Mesh>(std::move(vertices), std::move(triangles));
	}

	std::optional<Color> TryParseColor(const fkyaml::node& node, const std::string& property)
	{
		if (! node.contains(property))
			return std::nullopt;

		std::string value = TrimWhitespace(node[property].get_value<std::string>());

		static const std::regex normColorRegex("Color\\(" "([^\\,]+)" "," "([^\\,]+)" "," "([^\\)]+)" "\\)");
		if (std::smatch matches; std::regex_match(value, matches, normColorRegex))
		{
			auto r = DoubleFromString(matches[1]);
			auto g = DoubleFromString(matches[2]);
			auto b = DoubleFromString(matches[3]);

			return Color(r, g, b);
		}

		static const std::regex rgb888ColorRegex("ColorRGB888\\(" "([^\\,]+)" "," "([^\\,]+)" "," "([^\\)]+)" "\\)");
		if (std::smatch matches; std::regex_match(value, matches, rgb888ColorRegex))
		{
			auto r = std::clamp(DoubleFromString(matches[1]), 0.0, 255.0);
			auto g = std::clamp(DoubleFromString(matches[2]), 0.0, 255.0);
			auto b = std::clamp(DoubleFromString(matches[3]), 0.0, 255.0);

			return Color::FromRGB888(static_cast<uint8_t>(r), static_cast<uint8_t>(g), static_cast<uint8_t>(b));
		}

		static const std::map<std::string, Color> kKnownNames
			{
				{ "Red", Palette::kRed },
				{ "Green", Palette::kGreen },
				{ "Blue", Palette::kBlue },
				{ "Black", Palette::kBlack },
				{ "White", Palette::kWhite },
				{ "Cyan", Palette::kCyan },
				{ "Yellow", Palette::kYellow },
				{ "Magenta", Palette::kMagenta },
			};
		if (kKnownNames.contains(value))
			return kKnownNames.at(value);

		throw std::runtime_error("Unknown color type '" + value + "' specified in scene YAML file");
	}

	std::optional<Vector> TryParseVector(const fkyaml::node& node, const std::string& property)
	{
		if (! node.contains(property))
			return std::nullopt;

		std::string value = TrimWhitespace(node[property].get_value<std::string>());

		static const std::regex vectorRegex("Vector\\(" "([^\\,]+)" "," "([^\\,]+)" "," "([^\\)]+)" "\\)");
		if (std::smatch matches; std::regex_match(value, matches, vectorRegex))
		{
			auto x = DoubleFromString(matches[1]);
			auto y = DoubleFromString(matches[2]);
			auto z = DoubleFromString(matches[3]);

			return Vector(x, y, z);
		}

		static const std::regex degreesVectorRegex("VectorDegrees\\(" "([^\\,]+)" "," "([^\\,]+)" "," "([^\\)]+)" "\\)");
		if (std::smatch matches; std::regex_match(value, matches, degreesVectorRegex))
		{
			auto x = DegreesToRadians(DoubleFromString(matches[1]));
			auto y = DegreesToRadians(DoubleFromString(matches[2]));
			auto z = DegreesToRadians(DoubleFromString(matches[3]));

			return Vector(x, y, z);
		}

		static const std::map<std::string, Vector> kKnownNames
			{
				{ "Zero", Vector(0, 0, 0) },
				{ "Origin", StandardVectors::kOrigin },
				{ "UnitX", StandardVectors::kUnitX },
				{ "UnitY", StandardVectors::kUnitY },
				{ "UnitZ", StandardVectors::kUnitZ },
				{ "Unit", StandardVectors::kUnit },
			};
		if (kKnownNames.contains(value))
			return kKnownNames.at(value);

		throw std::runtime_error("Unknown vector type '" + value + "' specified in scene YAML file");
	}

	std::optional<Texture::Interpolation> TryParseInterpolation(const fkyaml::node& node, const std::string& property)
	{
		if (! node.contains(property))
			return std::nullopt;

		std::string value = TrimWhitespace(node[property].get_value<std::string>());

		static const std::map<std::string, Texture::Interpolation> kKnownNames
			{
				{ "NearestNeighbor", Texture::Interpolation::NearestNeighbor },
				{ "Bilinear", Texture::Interpolation::Bilinear },
			};
		if (kKnownNames.contains(value))
			return kKnownNames.at(value);

		throw std::runtime_error("Unknown interpolation type '" + value + "' specified in scene YAML file");
	}

	std::optional<double> TryParseAspectRatio(const fkyaml::node& node, const std::string& property)
	{
		if (! node.contains(property))
			return std::nullopt;

		const auto& valueNode = node[property];

		if (valueNode.is_float_number())
		{
			return valueNode.get_value<double>();
		}
		else
		{
			std::string value = TrimWhitespace(node[property].get_value<std::string>());

			static const std::regex aspectRatioRegex("([^\\,]+)" ":" "([^\\,]+)");
			if (std::smatch matches; std::regex_match(value, matches, aspectRatioRegex))
			{
				auto numerator		= DoubleFromString(matches[1]);
				auto denominator	= DoubleFromString(matches[2]);

				return numerator / denominator;
			}
		}

		throw std::runtime_error("Unknown aspect ratio type specified in scene YAML file");
	}

	std::optional<double> TryParseDouble(const fkyaml::node& node, const std::string& property)
	{
		if (! node.contains(property))
			return std::nullopt;

		const auto& valueNode = node[property];

		if (valueNode.is_float_number())
			return valueNode.get_value<double>();
		else if (valueNode.is_integer())
			return static_cast<double>(valueNode.get_value<int64_t>());
		else
			return DoubleFromString(valueNode.get_value<std::string>());
	}

	std::optional<Camera> TryParseCamera(const fkyaml::node& node, const std::string& property)
	{
		if (! node.contains(property))
			return std::nullopt;

		const auto cameraNode = node.at(property);

		auto position			= TryParseVector(cameraNode, "position").value_or(StandardVectors::kOrigin);
		auto target				= TryParseVector(cameraNode, "target").value_or(StandardVectors::kUnitZ);
		auto orientation		= TryParseVector(cameraNode, "orientation").value_or(StandardVectors::kUnitY);
		auto aspectRatio		= TryParseAspectRatio(cameraNode, "aspectRatio").value_or(16.0 / 9.0);
		auto verticalFov		= DegreesToRadians(TryParseDouble(cameraNode, "verticalFov").value_or(90));
		auto focusDistance		= TryParseDouble(cameraNode, "focusDistance").value_or(1.0);
		auto aperture			= TryParseDouble(cameraNode, "aperture").value_or(0.0);

		return Camera(position, target, orientation, aspectRatio, verticalFov, focusDistance, aperture);
	}

	std::shared_ptr<Texture> ParseCheckerboardTexture(const fkyaml::node& node)
	{
		auto color1				= TryParseColor(node, "color1").value_or(Palette::kMagenta);
		auto color2				= TryParseColor(node, "color2").value_or(Palette::kYellow);
		auto rowsCols			= TryParseDouble(node, "rowsCols").value_or(2);
		auto interpolation		= TryParseInterpolation(node, "interpolation").value_or(Texture::Interpolation::Bilinear);

		return std::make_shared<CheckerboardTexture>(interpolation, color1, color2, static_cast<uint8_t>(rowsCols));
	}

	std::shared_ptr<Texture> ParseImageTexture(const fkyaml::node& node)
	{
		auto path				= node.at("path").get_value<std::string>();
		auto multiplier			= TryParseColor(node, "multiplier").value_or(Palette::kWhite);
		auto interpolation		= TryParseInterpolation(node, "interpolation").value_or(Texture::Interpolation::Bilinear);

		return MakeImageTexture(path, multiplier, interpolation);
	}

	std::shared_ptr<Texture> ParseSolidTexture(const fkyaml::node& node)
	{
		auto color				= TryParseColor(node, "color").value_or(Palette::kWhite);

		return std::make_shared<SolidTexture>(color);
	}

	std::shared_ptr<Texture> ParseTexture(const fkyaml::node& node, const std::string& property)
	{
		if (! node.contains(property))
			return nullptr;

		const auto textureNode = node.at(property);

		const auto type = textureNode.at("type").get_value<std::string>();

		if (type == "Checkerboard")
			return ParseCheckerboardTexture(textureNode);
		else if (type == "Image")
			return ParseImageTexture(textureNode);
		else if (type == "Solid")
			return ParseSolidTexture(textureNode);
		else
			throw std::runtime_error("Unknown texture type '" + type + "' specified in scene YAML file");
	}

	std::shared_ptr<Material> ParseDebugMaterial(const fkyaml::node& node)
	{
		const auto mode = node.at("mode").get_value<std::string>();

		if (mode == "Normal")
			return std::make_shared<DebugMaterial>(DebugMaterial::Mode::Normal);
		else if (mode == "UV")
			return std::make_shared<DebugMaterial>(DebugMaterial::Mode::UV);
		else
			throw std::runtime_error("Unknown debug material mode '" + mode + "' specified in scene YAML file");
	}

	std::shared_ptr<Material> ParseDielectricMaterial(const fkyaml::node& node)
	{
		auto texture			= ParseTexture(node, "texture");
		auto normals			= ParseTexture(node, "normals");
		auto refractionIndex	= TryParseDouble(node, "refractionIndex").value_or(1.0);

		return std::make_shared<DielectricMaterial>(std::move(texture), std::move(normals), refractionIndex);
	}

	std::shared_ptr<Material> ParseDiffuseMaterial(const fkyaml::node& node)
	{
		auto texture			= ParseTexture(node, "texture");
		auto normals			= ParseTexture(node, "normals");

		return std::make_shared<DiffuseMaterial>(std::move(texture), std::move(normals));
	}

	std::shared_ptr<Material> ParseLightMaterial(const fkyaml::node& node)
	{
		auto texture			= ParseTexture(node, "texture");
		auto normals			= ParseTexture(node, "normals");

		return std::make_shared<LightMaterial>(std::move(texture), std::move(normals));
	}

	std::shared_ptr<Material> ParseReflectiveMaterial(const fkyaml::node& node)
	{
		auto texture			= ParseTexture(node, "texture");
		auto normals			= ParseTexture(node, "normals");
		auto polish				= TryParseDouble(node, "polish").value_or(1.0);

		return std::make_shared<ReflectiveMaterial>(std::move(texture), std::move(normals), polish);
	}

	std::shared_ptr<Material> ParseMaterial(const fkyaml::node& node)
	{
		const auto type = node.at("type").get_value<std::string>();

		if (type == "Debug")
			return ParseDebugMaterial(node);
		else if (type == "Dielectric")
			return ParseDielectricMaterial(node);
		else if (type == "Diffuse")
			return ParseDiffuseMaterial(node);
		else if (type == "Light")
			return ParseLightMaterial(node);
		else if (type == "Reflective")
			return ParseReflectiveMaterial(node);
		else
			throw std::runtime_error("Unknown material type '" + type + "' specified in scene YAML file");
	}

	Transform TryParseTransform(const fkyaml::node& node, const std::string& property)
	{
		if (! node.contains(property))
			return Transform();

		auto position			= TryParseVector(node, "position").value_or(StandardVectors::kOrigin);
		auto rotation			= TryParseVector(node, "rotation").value_or(StandardVectors::kZero);
		auto scale				= TryParseVector(node, "scale").value_or(StandardVectors::kUnit);

		return Transform(position, rotation, scale);
	}

	std::shared_ptr<Object> ParseBoxObject(const fkyaml::node& node)
	{
		auto transform			= ParseTransform(node, "transform");
		auto material			= ParseMaterial(node.at("material"));

		return std::make_shared<BoxObject>(transform, std::move(material));
	}

	std::shared_ptr<Object> ParsePlaneObject(const fkyaml::node& node)
	{
		auto material			= ParseMaterial(node.at("material"));
		auto normal				= TryParseVector(node, "normal").value_or(StandardVectors::kUnitY);
		auto distance			= TryParseDouble(node, "distance").value_or(0.0);
		auto uvScale			= TryParseDouble(node, "uvScale").value_or(1.0);

		return std::make_shared<PlaneObject>(std::move(material), normal, distance, uvScale);
	}

	std::shared_ptr<Object> ParseMeshObject(const fkyaml::node& node)
	{
		auto transform			= ParseTransform(node, "transform");
		auto material			= ParseMaterial(node.at("material"));
		auto path				= node.at("path").get_value<std::string>();

		return std::make_shared<MeshObject>(transform, std::move(material), MakeObjectMesh(path));
	}

	std::shared_ptr<Object> ParseSphereObject(const fkyaml::node& node)
	{
		auto transform			= ParseTransform(node, "transform");
		auto material			= ParseMaterial(node.at("material"));

		return std::make_shared<SphereObject>(transform, std::move(material));
	}

	std::vector<std::shared_ptr<Object>> ParseObjects(const fkyaml::node& node, const std::string& property)
	{
		if (! node.contains(property))
			return {};

		const auto objectsNode = node.at(property);

		std::vector<std::shared_ptr<Object>> objects;

		for (const auto& yamlObject : objectsNode)
		{
			const auto type = yamlObject.at("type").get_value<std::string>();

			if (type == "Box")
				objects.push_back(ParseBoxObject(yamlObject));
			else if (type == "Mesh")
				objects.push_back(ParseMeshObject(yamlObject));
			else if (type == "Plane")
				objects.push_back(ParsePlaneObject(yamlObject));
			else if (type == "Sphere")
				objects.push_back(ParseSphereObject(yamlObject));
			else
				throw std::runtime_error("Unknown object type '" + type + "' in scene YAML file");
		}

		return objects;
	}
}

Scene SceneLoader::Load(const std::string& path)
{
	std::ifstream config(path);
	if (! config)
		throw std::runtime_error("Failed to read scene YAML file '" + path + "'");

	fkyaml::node rootNode = fkyaml::node::deserialize(config);
	fkyaml::node sceneNode = rootNode.at("scene");

	return
		Scene
		{
			.background = TryParseColor(sceneNode, "background").value_or(Palette::kBlack),
			.camera = TryParseCamera(sceneNode, "camera").value_or(Camera()),
			.objects = ParseObjects(sceneNode, "objects"),
			.samplesPerPixel = std::max<uint32_t>(static_cast<uint32_t>(TryParseDouble(sceneNode, "samplesPerPixel").value_or(100)), 1)
		};
}
